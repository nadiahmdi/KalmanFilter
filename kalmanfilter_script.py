# -*- coding: utf-8 -*-
"""kalmanfilter_script

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QiEahnFXpqMxrc5yWDC7vD4bOoGsV6-Y
"""



"""### Import libraries:"""

import numpy as np
import matplotlib.pyplot as plt

"""### KalmanFilter Class Construction

### Prediction

* State Prediction:

$$
\hat{x}_{k|k-1} = A \hat{x}_{k-1|k-1} + B u_k
$$

* Covariance Prediction:

$$
P_{k|k-1} = A P_{k-1|k-1} A^T + Q
$$
#............................................................................................
### Update State Estimation
* Kalman Gain Calculation:
$$
K_k = P_{k|k-1} H^T (H P_{k|k-1} H^T + R)^{-1}
$$
* State Update:
$$
\hat{x}_{k|k} = \hat{x}_{k|k-1} + K_k (z_k - H \hat{x}_{k|k-1})
$$

* Covariance Update:
$$
P_{k|k} = (I - K_k H) P_{k|k-1}
$$
"""

class KalmanFilter:
  '''
  This is the class of Kalman Filter, which this KF algorithm is used for estimating the state of dynamic system from a series of incomplete and noisey measurement.
  This class KF has the initialization of required parameters, prediction or estimation step, and updating the system.
  The required parameters that are also mentioned in the slide, are:

  - A: (n x n) State transition matrix or system model
  - B: (n x 1) Control input matrix; it shows the effect of control input like gravity on state transitions A
  - H: (m x n) State to measurement or observation model
  - Q: (n x n) Process noise covariance matrix, that shows uncertainity in the model like variation in air resistance for example
  - R: (m x m) Observation noise covariance matrix, represents the uncertainty in the measurement
  - x_hat_init: (n x 1) State variable column vector, initial estimate of state vector, starting point for state estimation
  - P_init: (n x n) State covariance matrix, initial uncertainty in state estimation
  '''
  # initializing the parameters
  def __init__(self, A, B, H, Q, R, x_hat_init, P_init):
    self.A = A
    self.B = B
    self.H = H
    self.Q = Q
    self.R = R
    self.x_hat = x_hat_init
    self.P = P_init

  # function for predicting the next state and updating the estimate covariance based on the control input and the system model
  '''
  Function for prediction of next state and covariance estimate updating.
  Input:
  - u: control input vector, which affects the state transition A according to the control input matrix B

  Output:
  - x_hat: current state estimation or the prediction
  '''
  def predict(self, u):
    self.x_hat = self.A @ self.x_hat + self.B @ u   # the first part shows how the state evolves from one time step to the next, and the second part or sum shows how the control input affects the state
    self.P = self.A @ self.P @ self.A.T + self.Q # it transforms the current cov through the state transition matrix, or it propagates uncertainty through the system, with added noise Q
    return self.x_hat  # returns the predictated state

  # function for updating
  '''
  This function is used for correcting the predicted state and refine the state estimate.
  In here we use the Kalman Gain to balance the predicted state and the new measurement.

  Input:
  - z: it is the measurement vector contains the new observations and used to update the state estimate.

  Output:
  - x_hat: this is the updated state estimation after observing or incorporating the new measurement
  '''
  def update(self, z):
    if not np.isnan(z).any(): # it checks for the NaN values, if there are so, then the update step is going to be skipped
      K = self.P @ self.H.T @ np.linalg.inv(self.H @ self.P @ self.H.T + self.R) # Kalman Gain calculation
      self.x_hat = self.x_hat + K @ (z - self.H @ self.x_hat) # update the state estimate
      self.P = (np.eye(len(self.x_hat)) - K @ self.H) @ self.P # update the estimate covariance
    return self.x_hat  # returns the updated state estimate

"""### Ball Trajectory:"""

# this function shows the trajectory of ball
def simulate_ball_trajectory(dt, total_time, launch_position, launch_speed, launch_angle):
    """
    It simulates the trajectory of a ball given the launch parameters(position, speed, and angle) and returns the positions over time.

    Parameters:
    - g: Gravity (m/s^2), default is 9.81 and I defined it inside the function, if it is variable then we can set it as a parameter
    - dt: Time step (second)
    - total_time: Total simulation time (second)
    - launch_position: Initial position (x0, y0)
    - launch_speed: Launch speed (m/s)
    - launch_angle: Launch angle in degrees

    Returns:
    - true_positions: Array of shape (time_steps, 2) containing the x and y positions over time
    """

    # gravity
    g = 9.81
    # convert launch angle to radians
    launch_angle = np.radians(launch_angle)

    # calculate initial velocity or speed
    vx0 = launch_speed * np.cos(launch_angle)
    vy0 = launch_speed * np.sin(launch_angle)

    # generate the true trajectory of the ball
    time_steps = int(total_time / dt)
    true_positions = []

    for t in range(time_steps):
        x = launch_position[0] + vx0 * t * dt
        y = launch_position[1] + vy0 * t * dt - 0.5 * g * (t * dt) ** 2
        true_positions.append([x, y])

    true_positions = np.array(true_positions)

    # returns the true position of the ball
    return true_positions

# function for plotting the true trajectory of the ball
def simulate_ball_trajectory_plot(true_positions):
  plt.plot(true_positions[:, 0], true_positions[:, 1])
  plt.xlabel('Horizontal Positions (m)')
  plt.ylabel('Vertical Positions (m)')
  plt.title('True Trajectory of the Ball')
  plt.grid(True)
  plt.show()

"""### Observation with the noise:"""

# function for simulating the observations with the defined noise or uncertainty
def simulate_observations_with_noise(true_positions, noise_std):
    """
    This function stimulate the observations with standard deviation noise that is added on true positions.

    Parameters:
    - true_positions: Array of shape (time_steps, 2) containing the true x and y positions over time
    - noise_std: Array of shape (2,) containing the standard deviation of observation noise for x and y dimensions

    Returns:
    - observations: Array of shape (time_steps, 2) containing the observed x and y positions with the defined noise
    """

    # simulating the observations with standard deviation noise
    observations = true_positions + np.random.normal(0, noise_std, true_positions.shape)
    # return s the observations with the added noise
    return observations

# function for plotting observation with the added uncertainty
def simulate_observations_with_noise_plot(observations):
  plt.plot(observations[:, 0], observations[:, 1])
  plt.xlabel('Horizontal Positions (m)')
  plt.ylabel('Vertical Positions (m)')
  plt.title('Observations with the added uncertainty or noise')
  plt.grid(True)
  plt.show()

"""### Observation with the dropout intervals:"""

# this function simulates the observation dropouts
def simulate_observation_dropouts(observations, dropout_prob):
    """
    This function simulates the observation dropouts based on a dropout probability.

    Parameters:
    - observations: Array of shape (time_steps, 2) containing the observed x and y positions
    - dropout_prob: Probability of observation dropout

    Returns:
    - observations_with_dropout: Array of shape (time_steps, 2) containing the observed x and y positions with dropout
    """

    # simulate observation dropouts
    observations_with_dropout = np.copy(observations)
    for i in range(len(observations)):
        if np.random.rand() < dropout_prob:
            observations_with_dropout[i] = [np.nan, np.nan]
    # returns the observations with the dropout
    return observations_with_dropout

# function for plotting observation with the added uncertainty and dropout probability
def simulate_observations_with_noise_dropout_plot(observations_with_dropout):
  plt.plot(observations_with_dropout[:, 0], observations_with_dropout[:, 1])
  plt.xlabel('Horizontal Positions (m)')
  plt.ylabel('Vertical Positions (m)')
  plt.title('Noisey Observations with the dropout')
  plt.grid(True)
  plt.show()